/*************************************************************************************************/
/***********************灵敏度分析及灵敏度链式推导*********************************************/
/*************************************************************************************************/


Info<<"sensitivity analysis"<<endl;

/**************************计算柔度目标函数和体积约束的灵敏度****************************/

fsensh=-gradD&&(rho*(3*xh*xh*(E-Emin)/(2.0*(1.0 + Po))*twoSymm(gradD) + (3*xh*xh*Po*(E-Emin)/((1.0 + Po)*(1.0 - 2.0*Po))*I)*tr(gradD)));  
//柔度目标函数灵敏度计算公式，注意是对xh的灵敏度
for(i=0;i<n;i++)
{
 fsensh[i]=fsensh[i]*mesh.V()[i];
}
fsensh=fsensh/gMax(mag(fsensh.primitiveField()));// gMax返回内部和边界场的最大值，// primitiveField()返回无量纲的 内部场
gsensh.primitiveFieldRef()=mesh.V()/gMax(mesh.V()); // primitiveFieldRef()返回无量纲的 内部场，
//mag()取模，上面两行返回了各自灵敏度初以绝对值最大的那个，为什么？？？
//-------------------------------------------------------------------------------------------------------------------------//

/***********************************链式求对设计变量x的导数用于MMA****************************/

//这是在计算sp的表达式，函数phi对xh的导数乘以xh对xp的导数

if(opt>1)
{
  for(i=0;i<n;i++)
  {
     if(xp[i]<=eta5)
     {
         drho[i] = del * Foam::exp(-del * (1 - xp[i] / eta5)) + Foam::exp(-del);
         // del就是heviside过滤里的惩罚强度参数betta
         // eta5就是截断值小于该值的伪密度会倾向于罚为0；大于该值的倾向于罚为1。
         //每个优化步都需要计算 eta值来保证过滤前后材料用量一致，即保体积性
     }
     else
     {
         drho[i] = del * Foam::exp(-del * (xp[i] - eta5) / (1 - eta5)) + Foam::exp(-del);
     }
  }
  fsensh = fsensh * drho; // sp的表达式，函数phi对xh的导数乘以xh对xp的导数
  gsensh = gsensh * drho;
}




// 求解PDE得到函数phi对设计变量x的导数fens，这个导数用于MMA求解器

solve(fvm::laplacian(fsens) - fvm::Sp(b, fsens) + fsensh * b);//b就是1/r^2，之前已经定义
solve(fvm::laplacian(gsens) - fvm::Sp(b, gsens) + gsensh * b);

//最终得到了函数phi对设计变量x的导数，可带入MMA优化求解器求解更新设计变量
//-------------------------------------------------------------------------------------------------------------------------//