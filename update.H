/********************************************************************/
/*************************设计变量更新及求解场输出*****************/
/********************************************************************/

opt++; // 迭代次数增加

/************************计算结果输出*****************************/

if(solid_area)
{
    forAll(cells, i)
    {
        const xh[cells[i]] = 1.0; //对非设计域单元将设计变量置1,注意这里是对xh的，creatfields.H是对x的
    }
}
xh.correctBoundaryConditions();
//由于边界上的值是通过边界条件的类型从面相邻单元的内部场数据计算的来的，当内部场改变时，边界的值就需要从新计算

if(runTime.writeTime())
{
   xh.write();     
}
//---------------------------------------------------------------------------------------------//

/************************update mu and lambda******************/

mu = (Emin + xh * xh * xh * (E - Emin)) / (2.0 * (1.0 + Po)); //可以看出，xh参与下一次迭代中物理场的求解
lambda = (Emin + xh * xh * xh * (E - Emin)) * Po / ((1.0 + Po) * (1.0 - 2.0 * Po));
if (planeStress)
{
    lambda = (Emin + xh * xh * xh * (E - Emin)) * Po / ((1.0 + Po) * (1.0 - Po));
}
//---------------------------------------------------------------------------------------------//